// Global config
const CONFIG = require("../GODELTA_CONFIG");

// Test utils imports
const BigNumber = require("bignumber.js");
const Web3 = require("web3");
const web3 = new Web3("http://localhost:9545"); // Should match address and port of local ganache-cli instance

// Etherdelta Contract import
const Etherdelta = artifacts.require("./EtherDelta.sol");

// Deploy an ERC20 token for testing
const AlphaToken = artifacts.require("./AlphaToken.sol");

contract('Etherdelta', async (accounts) => {
    //===========
    //= Constants
    //===========
    const ETH_ADDR = "0x0000000000000000000000000000000000000000";

    // Etherdelta args
    let admin = accounts[0];
    let feeAccount = accounts[0];
    let accountLevelsAddr = "0x0000000000000000000000000000000000000000"; // By default, don't use account levels
    let feeTake = CONFIG.CONTRACT_CONFIG.feeTake;
    let feeMake = CONFIG.CONTRACT_CONFIG.feeMake;
    let feeRebate = CONFIG.CONTRACT_CONFIG.feeRebate;

    // Token Args
    const name = "Five Decimals";
    const symbol = "FIVD";
    const decimals = 5;

    const fee_factor = new BigNumber(feeTake).dividedBy(denormalizeBalance(1, 18));

    // Private keys generated by fixed mnemonic: "dead fish racket soul plunger dirty boats cracker mammal nicholas cage"
    const ACCOUNTS_PRIVATE = [
        "3e722ce009e8acbfad73048108d965b6e38c8d2051d4feaef9fe8d867de7f62c",
        "5bf0a56999d150c94943090182df4bcd40a4fd4b19a26d74e3493e613763bb8f",
        "977b30e8d19fb273611725a1a860ee5ec6221b8699e66828502111e661002737",
        "638f605652a78cc8267f5ca84eb94f65bf284b3761de1a146a7a8e1ae02ddd8d",
        "3918a55bcd6398b8a2216407b45e9fdbd075686092f7f929e41bee10be747f3f",
        "9e8ed2c6a653df5f4d71cd5b3546b34d85cb36f30f69139cebd0d23edad69488",
        "89f2b7b9671edd48acfd826412298ddb0ddc3368e73224baec9b67a27628dc83",
        "8757da7dc55d0f1ae62bf81acd5f7e5991acd3dc1d99db17ea7ed47d45c66e80",
        "8117c4e1b8246dbb3cb1fe5aa6a15174a4340e6f7faa71035944fe1f24019589",
        "c7449d28eaadac698f8ffad84e305688907de36fba5fa5dc1d4ec1e83b129656",
    ];

    //===========
    //= Deploy Section
    //===========
    let alpha_token;
    let etherdelta;
    it("Should deploy Etherdelta and ERC20 Token with symbol=FIVD and decimals=5", async () => {
        alpha_token = await AlphaToken.new(admin, name, symbol, decimals);
        etherdelta = await Etherdelta.new(
            admin,
            feeAccount,
            accountLevelsAddr,
            feeMake,
            feeTake,
            feeRebate,
        );

        // Check that owner variable is set (if it is, contract was deployed)
        let token_owner = await alpha_token.owner();
        let etherdelta_owner = await etherdelta.admin();

        assert.equal(token_owner, admin, "Token not successfully deployed");
        assert.equal(etherdelta_owner, admin, "Etherdelta not successfully deployed");
    });

    //===========
    //= Test Section
    //===========
    let sell_account = accounts[1];
    let sell_account_p_key = ACCOUNTS_PRIVATE[1];
    let buy_account = accounts[2];

    // Test ERC20 Mint
    let amount_to_mint = 15;
    amount_to_mint = denormalizeBalance(amount_to_mint, decimals);
    it("Should mint " + amount_to_mint + " of FIVD for sell_account", async () => {
        await alpha_token.mint(sell_account, amount_to_mint, {from: admin});

        let balance = await alpha_token.balanceOf(sell_account);

        assert.equal(balance, amount_to_mint, "Balance of sell_account does not reflect a successful mint for " + amount_to_mint + ". Instead balance is " + balance);
    });

    // Test Deposit of ERC20 into Etherdelta from sell_account
    let amount_to_deposit = 7.5;
    amount_to_deposit = denormalizeBalance(amount_to_deposit, decimals);
    it("Should approve and deposit " + amount_to_deposit + " of FIVD into etherdelta from sell_account", async () => {

        // Approve and deposit
        await alpha_token.approve(etherdelta.contract.address, amount_to_deposit, {from: sell_account});
        await etherdelta.depositToken(alpha_token.contract.address, amount_to_deposit, {from: sell_account});
        // Check balance
        let etherdelta_balance = await etherdelta.balanceOf(alpha_token.contract.address, sell_account);

        assert.equal(etherdelta_balance.toString(), amount_to_deposit.toString(), "Balance of sell_account does not reflect a successful deposit to contract for amount: " + amount_to_mint + ". Instead balance is " + etherdelta_balance);
    });

    // Test Deposit of ether into Etherdelta from buy_account
    let amount_of_eth_to_deposit = 5;
    amount_of_eth_to_deposit = denormalizeBalance(amount_of_eth_to_deposit, 18);
    it("Should deposit " + amount_of_eth_to_deposit + " of ETH into etherdelta from buy_account", async () => {

        // Deposit
        await etherdelta.deposit({from: buy_account, value: amount_of_eth_to_deposit});
        // Check balance
        let etherdelta_balance = await etherdelta.balanceOf(ETH_ADDR, buy_account);

        assert.equal(etherdelta_balance, amount_of_eth_to_deposit, "Balance of buy_account does not reflect a successful deposit of ETH to contract for amount: " + amount_of_eth_to_deposit + ". Instead balance is " + etherdelta_balance);
    });

    // Test buy_account filling a sell order placed by sell_account
    it("buy_account should fill half of a sell order placed by sell_account, and funds of buy, sell, and fee accounts should accurately reflect the fill.", async () => {
        // Check that balances before fill are valid
        let buy_eth_before = await etherdelta.balanceOf(ETH_ADDR, buy_account);
        let buy_token_before = await etherdelta.balanceOf(alpha_token.contract.address, buy_account);
        let sell_eth_before = await etherdelta.balanceOf(ETH_ADDR, sell_account);
        let sell_token_before = await etherdelta.balanceOf(alpha_token.contract.address, sell_account);
        let fee_account_eth_before = await etherdelta.balanceOf(ETH_ADDR, feeAccount);
        let fee_account_token_before = await etherdelta.balanceOf(alpha_token.contract.address, feeAccount);

        assert(buy_eth_before > 0, "Invalid Buy ETH Balance before reaching fill order");
        assert(buy_token_before.toString() === "0", "Invalid Buy Token Balance before reaching fill order");
        assert(sell_eth_before.toString() === "0", "Invalid Sell Eth Balance before reaching fill order");
        assert(sell_token_before > 0, "Invalid Sell Token Balance before reaching fill order");


        // Begin generating args for the fillOrder() function]
        let amount_get = denormalizeBalance(4, 18);
        let amount_give = denormalizeBalance(10, decimals);
        let order_args = [
            ETH_ADDR, // token_get
            amount_get, // amount_get
            alpha_token.contract.address, // token_give
            amount_give, // amount_give
            await web3.eth.getBlockNumber() + 1000, // expires
            await getNonce(sell_account), // nonce
        ];

        // Calculate price for calculations
        const price = new BigNumber(amount_get).dividedBy(amount_give);

        // Generate and sign hash
        const address_to = etherdelta.contract.address; // address_to
        const hash = generateOrderHash(address_to, ...order_args);
        const signed_hash = await web3.eth.sign(hash, sell_account, sell_account_p_key);

        // Add selling user to fillOrder() args
        order_args.push(sell_account);

        // Get ECDSA values from signature, https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethsign

        // v = signature[128:130] A hex (base 16) string that will be 27 or 28 in binary (base 10)
        let v = web3.utils.hexToNumber(signed_hash.slice(130, 132));
        // If 0 or 1, add 27
        if (v !== 27 || v !== 28) {
            v += 27;
        }
        order_args.push(v);

        // r = signature[0:64] bytes32 (string)
        order_args.push(signed_hash.slice(0, 66));

        // s = signature[64:128] bytes32 (string)
        order_args.push("0x" + signed_hash.slice(66, 130));

        // Push the last fillOrder() arg: amount of order for buy_account to buy
        let tokens_to_buy = denormalizeBalance(5, decimals);
        let amount_to_buy = new BigNumber(tokens_to_buy).multipliedBy(price); // Buying 5 of token at price in ETH units (bc fill amount is in tokenGet terms)

        order_args.push(amount_to_buy.toString());  // Buy half of the order

        // Place fillOrder() on smart contract
        await etherdelta.trade(
            order_args[0],
            order_args[1],
            order_args[2],
            order_args[3],
            order_args[4],
            order_args[5],
            order_args[6],
            order_args[7],
            order_args[8],
            order_args[9],
            order_args[10],
            {from: buy_account}
        );

        // Get balances after fillOrder() is places
        let buy_eth_after = await etherdelta.balanceOf(ETH_ADDR, buy_account);
        let buy_token_after = await etherdelta.balanceOf(alpha_token.contract.address, buy_account);
        let sell_eth_after = await etherdelta.balanceOf(ETH_ADDR, sell_account);
        let sell_token_after = await etherdelta.balanceOf(alpha_token.contract.address, sell_account);
        let fee_account_eth_after = await etherdelta.balanceOf(ETH_ADDR, feeAccount);
        let fee_account_token_after = await etherdelta.balanceOf(alpha_token.contract.address, feeAccount);

        // Find correct fee ETH balance post fill
        let total_fee = amount_to_buy.multipliedBy(fee_factor);
        let correct_fee_account_eth_after = new BigNumber(fee_account_eth_before).plus(total_fee);

        // Find correct buyer ETH balance post fill
        // previous_balance - (amount_bought + fee_taken)
        let amount_with_fee = amount_to_buy.plus(total_fee);
        let correct_buy_eth_after = new BigNumber(buy_eth_before).minus(amount_with_fee);

        // Find correct buyer token balance post fill
        let correct_buy_token_after = new BigNumber(buy_token_before).plus(new BigNumber(tokens_to_buy));

        // Find correct seller ETH balance post fill
        let correct_sell_eth_after = new BigNumber(sell_eth_before).plus(amount_to_buy);

        // Find correct seller token balance post fill
        let correct_sell_token_after = new BigNumber(sell_token_before).minus(new BigNumber(tokens_to_buy));

        assert.equal(correct_fee_account_eth_after.toString(), fee_account_eth_after.toString(), "Invalid fee account ETH balance post order fill.");
        assert.equal(fee_account_token_after.toString(), fee_account_token_before.toString(), "Fee account token balance should not have changed post fill.");
        assert.equal(buy_eth_after.toString(), correct_buy_eth_after.toString(), "Invalid Buy ETH Balance after placing fill order");
        assert.equal(buy_token_after.toString(), correct_buy_token_after.toString(), "Invalid Buy Token Balance after placing fill order");
        assert.equal(sell_eth_after.toString(), correct_sell_eth_after.toString(), "Invalid Sell Eth Balance after placing fill order");
        assert.equal(sell_token_after.toString(), correct_sell_token_after.toString(), "Invalid Sell Token Balance after placing fill order");
    });

});


//==============================
//= Utility / Helper Functions
//==============================
// From "eth" to "wei" units for X decimals (denormalized) where "eth" is the token's eth unit decimal equivalent
function denormalizeBalance(eth_value, token_decimals) {
    const eth_base = new BigNumber(eth_value.toString());
    const conversion_factor = new BigNumber(Math.pow(10, token_decimals).toString());
    return eth_base.multipliedBy(conversion_factor).toString();
}


// From "wei" to "eth" units for X decimals (normalized) where "eth" is the token's eth unit decimal equivalent
// export function normalizeBalance(wei_value, token_decimals) {
//     const wei_numerator = new BigNumber(wei_value.toString());
//     const conversion_denominator = new BigNumber(Math.pow(10, token_decimals).toString());
//     return wei_numerator.dividedBy(conversion_denominator).toString();
// }

// Generate keccak256() Solidity equivalent order hash
function generateOrderHash(
    address_to,
    token_get,
    amount_get,
    token_give,
    amount_give,
    expires,
    nonce
) {
    // Get sha3 hash corresponding to hash generated by Solidity
    return web3.utils.soliditySha3(
        {type: "address", value: address_to},
        {type: "address", value: token_get},
        {type: "uint256", value: amount_get},
        {type: "address", value: token_give},
        {type: "uint256", value: amount_give},
        {type: "uint256", value: expires},
        {type: "uint256", value: nonce},
    );
}

// Get's next transaction count for user (nonce)
export function getNonce(user_addr) {
    return new Promise((resolve) => web3.eth.getTransactionCount(user_addr).then((count) => {
            resolve(count + 1);
        }
    ))
}